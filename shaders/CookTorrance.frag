#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 0) out vec4 outColor;layout(binding = 1, set = 1) uniform sampler2D tex;layout(binding = 2, set = 1) uniform sampler2D detail;layout(binding = 0, set = 0) uniform GlobalUniformBufferObject {	vec3 lightDir;	vec4 lightColor;	vec3 eyePos;} gubo;const float PI = 3.14159265359;vec3 Fresnel(float cosTheta, vec3 F0) {	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);}float DistributionGGX(vec3 N, vec3 H, float roughness) {	float a = roughness * roughness;	float a2 = a * a;	float NdotH = max(dot(N, H), 0.0001f);	float NdotH2 = NdotH * NdotH;	float denom = (NdotH2 * (a2 - 1.0) + 1.0);	return a2 / (PI * denom * denom);}float GeometryGGX(float NdotV, float roughness) {	float r = (roughness + 1.0);	float k = (r * r) / 8.0;	return NdotV / (NdotV * (1.0 - k) + k);}float Geometry(vec3 N, vec3 V, vec3 L, float roughness) {	return GeometryGGX(max(dot(N, V), 0.0001f), roughness) *	GeometryGGX(max(dot(N, L), 0.0001f), roughness);}void main() {	vec3 N = normalize(fragNorm);	vec3 V = normalize(gubo.eyePos - fragPos);	vec3 L = normalize(gubo.lightDir);;	vec3 radiance = gubo.lightColor.rgb;	vec3 albedo = texture(tex, fragUV).rgb * (3.0 + texture(detail, fragUV)).rgb / 4.0;	vec3 H = normalize(V + L);	vec3 F0 = mix(vec3(0.04), albedo, 0.1);	float NDF = DistributionGGX(N, H, texture(detail, fragUV).r);	float G   = Geometry(N, V, L, texture(detail, fragUV).r);	vec3 F    = Fresnel(max(dot(H, V), 0.0), F0);	vec3 specular = (NDF * G * F) /	max(4.0 * max(dot(N, V), 0.0001f) * max(dot(N, L), 0.0), 0.0001f);	vec3 kS = F;	vec3 kD = vec3(1.0) - kS;	kD *= 1.0 - 0.1;	float NdotL = max(dot(N, L), 0.0);	vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;	// Ambient light contribution colors	const float scaling = 0.05f;	// blu	const vec3 cxp = vec3(0.2,0.5,0.9) * scaling;	// blu arancione	const vec3 cxn = vec3(0.9,0.6,0.7) * scaling;	// blu cielo	const vec3 cyp = vec3(0.2,0.7,1.0) * scaling;	// verde prato	const vec3 cyn = vec3(0.34,0.76,0.4) * scaling;	// arancione	const vec3 czp = vec3(0.9,0.6,0.0) * scaling;	// blu scuro	const vec3 czn = vec3(0.24,0.0,0.91) * scaling;	vec3 Ambient =((N.x > 0 ? cxp : cxn) * (N.x * N.x) +	(N.y > 0 ? cyp : cyn) * (N.y * N.y) +	(N.z > 0 ? czp : czn) * (N.z * N.z)) * albedo;	vec3 col  = Lo + Ambient;		outColor = vec4(col, 1.0f);}