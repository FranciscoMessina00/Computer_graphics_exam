#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec2 fragUV;layout(location = 3) in vec2 fragUV_world;layout(location = 0) out vec4 outColor;layout(binding = 1, set = 1) uniform sampler2D tex;layout(binding = 2, set = 1) uniform sampler2D detail;layout(binding = 0, set = 0) uniform GlobalUniformBufferGround {	vec3 lightDir;	vec4 lightColor;	vec3 eyePos;	vec3 airplanePos;} gubo;const float PI = 3.14159265359;const float stretchFactor = 0.7; // stretch factor for shadowconst float shadowSize = 3.0; // size of the shadowconst float maxShadowStrength = 0.5; // 0.0 = no shadow, 1.0 = full shadowconst float minShadowStrength = 0.01;// Normal Distribution function --------------------------------------float DistributionGGX(float dotNH, float roughness){	float alpha = roughness * roughness;	float alpha2 = alpha * alpha;	float denom = dotNH * dotNH * (alpha2 - 1.0f) + 1.0f;	return (alpha2)/(PI * denom*denom); }// Geometric Shadowing function --------------------------------------float GeometricSchlicksmithGGX(float dotNL, float dotNV, float roughness){	float r = (roughness + 1.0f);	float k = (r*r) / 8.0f;	// we take into account of both the view direction (geometry obstruction) and	// the light direction vector (geometry shadowing)	float GL = dotNL / (dotNL * (1.0f - k) + k);	float GV = dotNV / (dotNV * (1.0f - k) + k);	return GL * GV;}// Fresnel function ----------------------------------------------------vec3 FresnelSchlick(float cosTheta, float metallic, vec3 materialcolor){	vec3 F0 = mix(vec3(0.04f), materialcolor, metallic); // * material.specular	vec3 F = F0 + (vec3(1.0f) - F0) * pow(1.0f - cosTheta, 5.0f); 	return F;    }// Specular BRDF composition --------------------------------------------vec3 BRDF(vec3 L, vec3 V, vec3 N, float metallic, float roughness, vec3 materialcolor){	// Precalculate vectors and dot products		vec3 H = normalize (V + L);	float dotNV = clamp(dot(N, V), 0.0f, 1.0f);	float dotNL = clamp(dot(N, L), 0.0f, 1.0f);	float dotLH = clamp(dot(L, H), 0.0f, 1.0f);	float dotNH = clamp(dot(N, H), 0.0f, 1.0f);	vec3 color = vec3(0.0f);	if (dotNL > 0.0f)	{		float rroughness = max(0.05f, roughness);		// D = Normal distribution (Distribution of the microfacets)		float D = DistributionGGX(dotNH, roughness);		// G = Geometric shadowing term (Microfacets shadowing)		float G = GeometricSchlicksmithGGX(dotNL, dotNV, rroughness);		// F = Fresnel factor (Reflectance depending on angle of incidence)		vec3 F = FresnelSchlick(dotNV, metallic, materialcolor);		vec3 spec = D * F * G / (4.0f * dotNV);		color += spec;	}	return color;}// ------------------------------------------------------------// a tiny 2D hash:  maps integer 2D coords -> [0,1)float hash12(vec2 p) {	// a classic “sin dot” trick	return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);}// rotate a 2D vector around (0,0) by angle θ:vec2 rotate2D(vec2 v, float theta) {	float c = cos(theta), s = sin(theta);	return vec2(c*v.x - s*v.y,	s*v.x + c*v.y);}void main() {	vec3 Norm = normalize(fragNorm);	vec3 EyeDir = normalize(gubo.eyePos - fragPos);		vec3 lightDir = gubo.lightDir;	vec3 lightColor = gubo.lightColor.rgb;	// -------------- simple shadow	vec3 planeProjected = gubo.airplanePos - gubo.lightDir * gubo.airplanePos.y / gubo.lightDir.y;	vec2 shadowCenter = planeProjected.xz;	vec2 fragXZ = fragPos.xz;	vec2 lightXZ = normalize(gubo.lightDir.xz);	vec2 dir = fragXZ - shadowCenter;	float d = dot(dir, lightXZ); // stretch along light	float ortho = length(dir - lightXZ * d); // perpendicular	float dist = sqrt((d * d) * stretchFactor + ortho * ortho);	//float dist = length(fragXZ - shadowCenter);	// Adjust shadow size based on airplane height	float shadowRadius = clamp(shadowSize - gubo.airplanePos.y * 0.05, 0.0, shadowSize);	float height = gubo.airplanePos.y;	float shadowStrength = mix(maxShadowStrength, minShadowStrength, clamp(height / 50.0, 0.0, 1.0));	// soft circular shadow (dark center, smooth edges)	float shadow = 1.0 - smoothstep(shadowRadius * 0.4, shadowRadius, dist);	// --------------	// -------------- tiled texture	const float TILE_SIZE = 1.f;	vec2 worldXZ   = fragUV_world / TILE_SIZE;	vec2 camOff  = gubo.airplanePos.xz / TILE_SIZE;	vec2 tileID = floor(worldXZ + camOff);	vec2 tiledUV = fract(worldXZ + camOff);	// --- generate per‐tile randomness ---	float rndRot = hash12(tileID);          // [0,1)	float angle  = rndRot * 2.0 * PI;        // full 0→2π	float rndOff = (hash12(tileID + 0.5) - 0.5) * 0.3;	//   second hash for an offset in [-0.15, +0.15]	// --- apply them around the tile‐center (0.5,0.5) ---	vec2 uv = tiledUV - 0.5;	uv = rotate2D(uv, angle);	uv += 0.5 + vec2(rndOff);	// uv = tiledUV;	// --------------	vec3 baseColor = texture(tex,    uv).rgb;	vec3 detailColor = texture(detail, uv).rgb;	vec3 albedo = mix(baseColor, detailColor, 0.25);	// 25% detail, 75% base		vec3 Diffuse = albedo * clamp(dot(Norm, lightDir),0.0f,1.0f);//	vec3 Specular = vec3(pow(clamp(dot(Norm, normalize(lightDir + EyeDir)),0.0,1.0), 160.0f));	vec3 Specular = BRDF(lightDir, EyeDir, Norm, 0.01f, 0.8f, albedo);	vec3 Ambient = albedo;	vec3 col  = (Diffuse + Specular) * lightColor + Ambient;	col *= mix(vec3(1.0), vec3(1.0 - shadowStrength), shadow);		outColor = vec4(col, 1.0f);}